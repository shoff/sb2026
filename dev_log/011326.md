## Summary

Fixed broken startup asset loading by correcting repo-root path resolution in `main.py` (previously pointed outside the repo, resulting in an empty asset browser). Added fail-fast validation in `assets/asset_manager.py` so a missing/malformed `arcane_dump/` produces a clear startup error instead of silent empty UI.

Extended texture handling in `assets/asset_manager.py` to index and load `.tga` textures (current dump format) in addition to `.jpg`, so textures appear in the browser and can be applied to meshes.

Installed missing runtime dependencies from `requirements.txt` (notably `PyOpenGL` / `PyOpenGL-accelerate`) so the viewer can start without `ModuleNotFoundError`.

Implemented an initial assembled-asset browsing layer:

- Added `assets/asset_catalog.py` to treat `COBJECTS` as the primary assets and assemble them via `RENDER` → `MESH`/`TEXTURE` references.
- Replaced the old cache-type tree widget with `ui/asset_catalog.py` (category list + searchable asset list + inspector).
- Extended `ui/opengl_viewport.py` to render multi-mesh assembled assets by drawing a list of mesh parts with per-part transforms.

Hardened asset indexing so nested `arcane_dump/COBJECTS/<CATEGORY>/` layouts are discoverable and loadable:

- `AssetManager` now builds a disk index at startup and resolves JSON paths via that index (fixes “COBJECTS show 0 assets”).
- `arcane/ArcCObject.py` now filters out zero render IDs to avoid bogus `render_id=0` references.

Fixed OpenGL VAO crash when selecting assembled assets:

- `ui/opengl_viewport.py` now wraps GPU uploads in `makeCurrent()`/`doneCurrent()` so VAO/VBO creation happens in the correct `QOpenGLWidget` context.
- Added a small deferred-load mechanism so selections made before `initializeGL` are applied after GL initialization instead of crashing.

Fixed creature (RUNE) assembly so they render:

- `arcane/ArcCObject.py` now collects creature render IDs from `rune_body_parts[*].body_part_render` (and `rune_hair`/`rune_beard` when present), and captures `rune_skeleton` as the skeleton reference.
- `assets/asset_catalog.py` now ignores invalid mesh IDs (`polymesh_id=0`) so we don’t attempt to load `MESH/0.json`.

Started evidence-backed reverse engineering of `sb.exe` asset pipeline using the working Ghidra MCP server and produced initial implementation-grade docs:

- Confirmed cache roots `cache/Text/` and `cache/Binary/` and multiple text-driven formats (ArcMesh/ArcMotion/ArcSkeleton/RenderObject tag blocks).
- Documented confirmed parse rules, tags, and key field offsets for render/template keywords, mesh sets, and texture sets.
- Added deliverables: `ASSET_PIPELINE_OVERVIEW.md`, `MODEL_ASSEMBLY_SPEC.md`, `ENTITY_BINDING_SPEC.md`, `IMPLEMENTATION_GAP_REPORT.md`.

## Current Work

Task C reverse engineering: anchor the original client assembly pipeline in decompiled functions and reconcile with current viewer assembly.

## Remaining Tasks

- Improve assembled-asset UI: composition graph view (hierarchy/attachments), richer metadata, and better filtering of assets with missing render chains (Task B)
- Add skeleton/attachment rules into assembly (requires Task C reverse engineering)
- Expand Ghidra-derived docs to cover full load→assemble pipeline for meshes/textures/shaders/animations/entities (Task C deliverables)

## Recommendations

- Add an “asset catalog” layer backed by `COBJECTS` + `RENDER` records (category + search + composition inspector)
- Add a small non-GUI smoke test that asserts the dump layout exists and that at least one CObject/Render/Mesh ID is discoverable
