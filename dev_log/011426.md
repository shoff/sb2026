## Summary
Continued Phase B checkpoint B5: scanned draw-helper anchors for callers and decompiled the immediate-path caller, then attempted to climb one level up toward ArcRenderObject but hit an undefined-function gap at callsite `0x0040b979` (only a data xref at `0x015498cc`).
Attempted B6 function discovery around `0x0040b979`; the only defined code at that address is `thunk_FUN_005b6790` (single `JMP 0x005b6790`), and no containing function exists at `0x0040b900` in the current database.
Provided consolidated plan summary for Phase B checkpoints and remaining blockers.
Attempted B2.5 thunk resolution for vtable targets at `0x0041a195` and `0x00426f49`; confirmed vtable entry pointers via data xrefs but could not disassemble or decompile targets because no function exists at or containing those addresses.
Attempted B3: decompiled `FUN_005db470` and confirmed it returns the value at `[vtable+0x08]` via out-param; dumped vtable entries at `0x0154ebd8` but candidate method decompiles still fail due to missing function definitions at the entry addresses.
Ingested `sb.exe_B3_dispatch_vtable_fix_report.md`; resolved vtable slot +0x0C to `FUN_0043cc70` and slot +0x14 to `FUN_005311b0` (both JMP thunks from `0x0041a195` and `0x00426f49`) and decompiled both; neither touches mesh/index/vertex buffers or ArcRenderObject fields.
Attempted B5: helper xrefs for `FUN_005a0740/0780/07f0` returned none; immediate-path caller `FUN_005b6790` decompiled and confirmed `thunk_FUN_005aadc0` usage with state flags at `this+0x10/0x11`, but indexed-path caller remains unresolved due to missing xrefs.
Ingested `sb.exe_B5_draw_helper_callers_scan` artifacts; scan only reports `FUN_005aadc0` via `FUN_005b6790` callsite `0x005b67a7` with setup window showing `this+0x14` and flags at `this+0x10/0x11`.
Re-ran B6 caller chain: `FUN_005b6790` is only called by `thunk_FUN_005b6790 @ 0x0040b979`; `FUN_005b6760` is called at `0x00408f99`, but no defined function exists at/around `0x00408f99`, blocking connector identification.
Attempted to ingest `sb.exe_B6_unblock_00408F99_report.md`, but it is not present in `ghidra_scripts/`; no Ghidra headless runner found to execute the script from the shell.
Ingested `sb.exe_B6_unblock_00408F99_report.md`; created `thunk_FUN_005b6760 @ 0x00408f99` (body `0x00408f99..0x00408f9d`) with data ref `0x015498c8`, no direct code callers beyond the vtable table entry.
Ingested `sb.exe_B6_indirect_calls_015498C8_and_slot28` scan; selected indirect callsite `0x0045c3d6` in `FUN_0045c3a0` for slot+0x28 dispatch and documented the immediate-mode chain in `ASSEMBLED_MODEL_RUNTIME_TYPE.md` and `RENDER_BACKEND_AND_VERTEX_FORMAT.md`.
Ingested `sb.exe_B6_vtable_015498A0_dump` and classified the vtable owner as Unnamed Render Dispatch Object; documented vtable base, RTTI absence, and vtable-write sites in the render docs.
Rewrote the viewer spec to separate DispatchCarrier and ImmediateSubmitNode roles and removed unproven field assumptions.
Reissued the viewer spec with explicit DispatchCarrier/ImmediateSubmitNode roles and added Missing Proof to Merge Roles section.
Merge scan shows STRONG_MERGE_SIGNAL for vtable writes at `0x015498A0` with offsets `{0x10,0x11,0x14}` on the same base register.
Merged DispatchCarrier and ImmediateSubmitNode in viewer spec, updated render docs.
Attempted viewer schema tasks; missing `sb_aadc0_renderpayload_offsets.json` in `ghidra_scripts/`, cannot complete schema or code patch yet.
Ingested `sb_aadc0_renderpayload_offsets.json` (no offsets recorded), recovered RenderPayload layout from `FUN_005aadc0` disassembly, and documented per-offset evidence.
Created `runtime_render_schema.json` and `RENDER_PAYLOAD_LAYOUT.md`, updated render docs with immediate payload pointers and vertex-count behavior.
Implemented runtime dispatch parsing (`rendering/runtime_render_payload.py`) plus `OpenGLViewport.load_runtime_dispatch` and immediate payload rendering path in `MeshRenderer`.
Added runtime tracing and no-draw mode flags for immediate submissions and payload dumps; added standalone `runtime_render_harness.py` to parse a dispatch dump and emit decoded vertices without GL.
Expanded ctor write report in `sb_immediate_dispatch_ctor_writes.json` with concrete [this+disp] writes around each vtable write site.
Added in-viewer dispatch dump generator (`rendering/runtime_dispatch_dump.py`) and `OpenGLViewport.dump_runtime_dispatches` with Ctrl+D hook to emit harness-compatible dumps.
Hotspot artifact files missing in workspace; glob search returned none.
Checked `D:\pdev\sb2026\ghidra_scripts` directly; no `sb.exe_hotspot_*` artifacts present.
Found related artifacts instead: `sb.exe_obj_field_usage_report.*`, `sb.exe_obj_field_usage_call_target_rank.*`, `sb.exe_cache_lookup_hotspots.*`, `sb.exe_alloc_ctor_report.*`, `sb.exe_top_call_targets_xrefs.md`.
Current authoritative artifacts are sparse: field usage report has zero field reads, ranked targets and cache hotspots lists are empty.
Confirmed the active Ghidra MCP target is a `sb.exe` image (PE base `0x00400000`) and extracted new evidence for the **monolithic `*.cache` container implementation** inside `sb.exe`.

- **Container selection**: `FUN_007dba30` appends `PTR_s_Textures_0170508c[subtype]` + `".cache"` (`0x01704f08`).
- **Header+directory writer**: `FUN_007dcba0` writes a **0x10-byte header** then **0x14-byte directory records** containing `(ArcCacheID lo/hi, stream_off, uncompressed_size, compressed_size)`.
- **Lookup primitive**: `FUN_007db8f0` performs **binary search** over the directory vector (stride `0x18`) comparing by full `ArcCacheID` (two dwords).

Updated `project_information.md`, `CACHE_CONTAINER_FORMATS.md`, and `CONCRETE_ID_TO_OBJECT_PROOF.md` to record these concrete functions and the header-size inconsistency that must be reconciled against a real cache file from disk.
Resolved the 3 critical indirections to concrete targets:
- `ArcFileCache` vtable slot `+8` (`BuildPathFromID`) → `FUN_007da120` (proven by vtable base `0x0155a97c` + XREF at `0x0155a984`)
- `open_decode_fn` (`this+0x84`) and `binary_load_fn` (`this+0x50`) per cache subtype via `FUN_0091d6b0` wiring + thunk resolution using `get_xrefs_from()`.
Confirmed two “easy” asset pipelines end-to-end at the function level:
- **ArcImage**: `open_decode` `FUN_0058eb90` + `ArcImage::Load` (`FUN_0058dd50`) + `ArcImage::TextureGLInit` (`FUN_00590a90`), with binary loader `FUN_0058efb0`.
- **ArcMesh**: binary loader `FUN_005a33e0` + CPU vertex attribute accessors `FUN_005a43a0/FUN_005a4460/FUN_005a4530` proving float3/float2 widths.
Authored new evidence-backed docs: `ASSET_LOADER_DISPATCH_SPEC.md`, `BINARY_CACHE_FORMATS.md`, `CONCRETE_ID_TO_OBJECT_PROOF.md`, and updated `CACHE_MISS_OPEN_CHAIN.md`. Added initial stubs for `RENDER_BACKEND_AND_VERTEX_FORMAT.md`, `ASSEMBLED_MODEL_RUNTIME_TYPE.md`, and `SKINNING_PIPELINE_SPEC.md`.
Ground-truthed the repo’s real `cache/` directory: it contains 13 monolithic `.cache` containers (no on-disk `^\d{20}` filenames). Verified `cache/Mesh.cache` and `cache/Textures.cache` Variant B headers and directory layout by raw hex + offset math:

- 0x28-byte header (10×u32); `file_size` matches actual length; payload begins at `data_off` (`0x78 ??` zlib header bytes present at `data_off`)
- directory entries: 0x10 bytes of data (`key,stream_off,usize,csize`) plus a 4-byte pad between entries; pad absent after the last entry (the “pad” overlaps the first payload dword for the final entry)

Produced 5 worked disk-backed examples (2 Mesh + 3 Textures) with exact dir-entry offsets+bytes and zlib inflate size checks, mapped to proven decoders:

- `ArcMesh → FUN_005a33e0`
- `ArcImage → FUN_0058efb0`
Started filling `ASSEMBLED_MODEL_RUNTIME_TYPE.md` with concrete `ArcRenderObject` evidence (RTTI + ArcRenderObject.cpp path strings, child composition + texture-set recursion with field offsets).
Updated `CACHE_CONTAINER_FORMATS.md` to explicitly document **multiple on-disk variants**: `sb.exe` Variant A (0x10 header, u64 ArcCacheID keys) vs repo Variant B (0x28 header, u32 keys + per-entry pad) and which repo files fall into each bucket.

## Current Work
- Expanding reverse engineering scope beyond `sb.exe` to include `Core.dll`, `Math.dll`, and `Skin.dll` using Ghidra MCP evidence (exports/RTTI/strings/XREF chains).
- Locating evidence-backed implementations for:
  - cache ID parsing/normalization and cache path resolution
  - binary cache readers and object construction
  - renderer-consumed assembled model runtime type
  - GPU upload path and vertex declarations
- Phase B B5: identifying callers of `FUN_005a0740/0780/07f0/adc0`, selecting best caller candidates, and bridging from `FUN_005b6790` to the containing function at `0x0040b979`.

- In `sb.exe`, tracing cache lookup/insert call chains around `FUN_005b72d0` → `FUN_00440db0` and directory indexing (`findfirst/findnext`) to prove `OpenAsset(id)` behavior and cache resolution/fallback rules.
- Tracing `ArcFileCache` indirect calls to resolve the concrete “build path”, “open stream”, and “decode” functions per asset type and to enumerate binary cache formats and render integration points.

## Remaining Tasks
- Prove one **concrete, real** cache filename/ID pair from an actual install cache (or extracted `.cache`) to close the strict “ID → exact disk path” stop condition with a real-world example.
- Tighten the `.cache` container proof to the strict stop condition phrasing by proving whether the container directory `key` is the full `ArcCacheID` (low-only) or a separate 32-bit ID mapped to `ArcCacheID` elsewhere.
- Trace `ArcMesh` (or `ArcMeshRep`) forward into actual GL draw submission and confirm the definitive GPU vertex declaration(s), including skinned variants.
- Switch the active Ghidra program and repeat the evidence sweep for `Math.dll` and `Skin.dll` to complete ownership + skinning specs.
- Update `IMPLEMENTATION_GAP_REPORT.md` with exact next code changes for the Python viewer based on recovered specs.

## Recommendations
- Ensure each recovered rule is anchored by at least one of: exported symbol, RTTI/class name, string, or XREF-to-function chain, then capture it into the corresponding deliverable doc immediately to avoid evidence drift.
