## Summary
Continued Phase B checkpoint B5: scanned draw-helper anchors for callers and decompiled the immediate-path caller, then attempted to climb one level up toward ArcRenderObject but hit an undefined-function gap at callsite `0x0040b979` (only a data xref at `0x015498cc`).
Confirmed the active Ghidra MCP target is a `sb.exe` image (PE base `0x00400000`) and extracted new evidence for the **monolithic `*.cache` container implementation** inside `sb.exe`.

- **Container selection**: `FUN_007dba30` appends `PTR_s_Textures_0170508c[subtype]` + `".cache"` (`0x01704f08`).
- **Header+directory writer**: `FUN_007dcba0` writes a **0x10-byte header** then **0x14-byte directory records** containing `(ArcCacheID lo/hi, stream_off, uncompressed_size, compressed_size)`.
- **Lookup primitive**: `FUN_007db8f0` performs **binary search** over the directory vector (stride `0x18`) comparing by full `ArcCacheID` (two dwords).

Updated `project_information.md`, `CACHE_CONTAINER_FORMATS.md`, and `CONCRETE_ID_TO_OBJECT_PROOF.md` to record these concrete functions and the header-size inconsistency that must be reconciled against a real cache file from disk.
Resolved the 3 critical indirections to concrete targets:
- `ArcFileCache` vtable slot `+8` (`BuildPathFromID`) → `FUN_007da120` (proven by vtable base `0x0155a97c` + XREF at `0x0155a984`)
- `open_decode_fn` (`this+0x84`) and `binary_load_fn` (`this+0x50`) per cache subtype via `FUN_0091d6b0` wiring + thunk resolution using `get_xrefs_from()`.
Confirmed two “easy” asset pipelines end-to-end at the function level:
- **ArcImage**: `open_decode` `FUN_0058eb90` + `ArcImage::Load` (`FUN_0058dd50`) + `ArcImage::TextureGLInit` (`FUN_00590a90`), with binary loader `FUN_0058efb0`.
- **ArcMesh**: binary loader `FUN_005a33e0` + CPU vertex attribute accessors `FUN_005a43a0/FUN_005a4460/FUN_005a4530` proving float3/float2 widths.
Authored new evidence-backed docs: `ASSET_LOADER_DISPATCH_SPEC.md`, `BINARY_CACHE_FORMATS.md`, `CONCRETE_ID_TO_OBJECT_PROOF.md`, and updated `CACHE_MISS_OPEN_CHAIN.md`. Added initial stubs for `RENDER_BACKEND_AND_VERTEX_FORMAT.md`, `ASSEMBLED_MODEL_RUNTIME_TYPE.md`, and `SKINNING_PIPELINE_SPEC.md`.
Ground-truthed the repo’s real `cache/` directory: it contains 13 monolithic `.cache` containers (no on-disk `^\d{20}` filenames). Verified `cache/Mesh.cache` and `cache/Textures.cache` Variant B headers and directory layout by raw hex + offset math:

- 0x28-byte header (10×u32); `file_size` matches actual length; payload begins at `data_off` (`0x78 ??` zlib header bytes present at `data_off`)
- directory entries: 0x10 bytes of data (`key,stream_off,usize,csize`) plus a 4-byte pad between entries; pad absent after the last entry (the “pad” overlaps the first payload dword for the final entry)

Produced 5 worked disk-backed examples (2 Mesh + 3 Textures) with exact dir-entry offsets+bytes and zlib inflate size checks, mapped to proven decoders:

- `ArcMesh → FUN_005a33e0`
- `ArcImage → FUN_0058efb0`
Started filling `ASSEMBLED_MODEL_RUNTIME_TYPE.md` with concrete `ArcRenderObject` evidence (RTTI + ArcRenderObject.cpp path strings, child composition + texture-set recursion with field offsets).
Updated `CACHE_CONTAINER_FORMATS.md` to explicitly document **multiple on-disk variants**: `sb.exe` Variant A (0x10 header, u64 ArcCacheID keys) vs repo Variant B (0x28 header, u32 keys + per-entry pad) and which repo files fall into each bucket.

## Current Work
- Expanding reverse engineering scope beyond `sb.exe` to include `Core.dll`, `Math.dll`, and `Skin.dll` using Ghidra MCP evidence (exports/RTTI/strings/XREF chains).
- Locating evidence-backed implementations for:
  - cache ID parsing/normalization and cache path resolution
  - binary cache readers and object construction
  - renderer-consumed assembled model runtime type
  - GPU upload path and vertex declarations
- Phase B B5: identifying callers of `FUN_005a0740/0780/07f0/adc0`, selecting best caller candidates, and bridging from `FUN_005b6790` to the containing function at `0x0040b979`.

- In `sb.exe`, tracing cache lookup/insert call chains around `FUN_005b72d0` → `FUN_00440db0` and directory indexing (`findfirst/findnext`) to prove `OpenAsset(id)` behavior and cache resolution/fallback rules.
- Tracing `ArcFileCache` indirect calls to resolve the concrete “build path”, “open stream”, and “decode” functions per asset type and to enumerate binary cache formats and render integration points.

## Remaining Tasks
- Prove one **concrete, real** cache filename/ID pair from an actual install cache (or extracted `.cache`) to close the strict “ID → exact disk path” stop condition with a real-world example.
- Tighten the `.cache` container proof to the strict stop condition phrasing by proving whether the container directory `key` is the full `ArcCacheID` (low-only) or a separate 32-bit ID mapped to `ArcCacheID` elsewhere.
- Trace `ArcMesh` (or `ArcMeshRep`) forward into actual GL draw submission and confirm the definitive GPU vertex declaration(s), including skinned variants.
- Switch the active Ghidra program and repeat the evidence sweep for `Math.dll` and `Skin.dll` to complete ownership + skinning specs.
- Update `IMPLEMENTATION_GAP_REPORT.md` with exact next code changes for the Python viewer based on recovered specs.

## Recommendations
- Ensure each recovered rule is anchored by at least one of: exported symbol, RTTI/class name, string, or XREF-to-function chain, then capture it into the corresponding deliverable doc immediately to avoid evidence drift.
